#include <regdef.h>
#include <la32regs.h>
#include <unistd.h>
#include <exception.h>
#include <shell.h>


    .section .text.utest
    .p2align 2

    // Simple test program
    // Write integer 1 to register a0
UTEST_SIMPLE:
    li.w a0, 0x1
    jr ra

    // STREAM test program
    // Continous memory read/write
UTEST_STREAM:
    li.w a0, 0x80100000
    li.w a1, 0x80400000
    li.w a2, 0x00300000
    add.w a2, a0, a2
stream_next:
    ld.w t0, a0, 0
    st.w t0, a1, 0
    addi.w a1, a1, 4
    addi.w a0, a0, 4
    bne a0, a2, stream_next

stream_end:
    jr ra

    //  MATRIX test program
    //  Matrix multiplication
    //  Reference C code:
    //  void matrix(int a[128][128],int b[128][128],int c[128][128],unsigned int n) {
    //      unsigned int i,j,k;
    //      for (k=0; k!=n; k++) {
    //          for (i=0; i!=n; i++) {
    //              int r = a[i][k];
    //              for (j=0; j!=n; j++)
    //                  c[i][j] += r * b[k][j];
    //          }
    //      }
    //  }
    //
UTEST_MATRIX:
    // set arguments
    // a0 -> a
    // a1 -> b
    // a2 -> c
    // a3 -> n
    li.w a0, 0x80400000
    li.w a1, 0x80410000
    li.w a2, 0x80420000
    li.w a3, 96

    // generated by gcc
    beq $r7,$r0,.L1
    slli.w $r12,$r7,9
    or $r20,$r5,$r0
    add.w $r8,$r20,$r12
    or $r5,$r4,$r0
    add.w $r4,$r6,$r12
.L3:
    or $r18,$r6,$r0
    or $r19,$r5,$r0
.L5:
    ld.w $r17,$r19,0
    or $r16,$r20,$r0
    or $r12,$r18,$r0
    or $r15,$r0,$r0
.L4:
    ld.w $r14,$r16,0
    ld.w $r13,$r12,0
    addi.w $r12,$r12,4
    mul.w $r14,$r17,$r14
    addi.w $r15,$r15,1
    addi.w $r16,$r16,4
    add.w $r13,$r13,$r14
    st.w $r13,$r12,-4
    bne $r7,$r15,.L4
    addi.w $r18,$r18,512
    addi.w $r19,$r19,512
    bne $r4,$r18,.L5
    addi.w $r20,$r20,512
    addi.w $r5,$r5,4
    bne $r20,$r8,.L3
.L1:
    jr $r1

    //  CryptoNight test program
    //  Run simplified CryptoNight memory-hard loop
    //  Reference C code:
    //  void crn(int pad[],unsigned int a,unsigned int b,unsigned int n) {
    //      unsigned int k;
    //      for (k=0; k!=0x80000; k++)
    //          pad[k] = k;
    //      for (k=0; k!=n; k++) {
    //          unsigned int t, addr1, addr2;
    //          addr1 = a & 0x7FFFF;
    //          t = (a >> 1) ^ (pad[addr1] << 1); // Replace the AES step
    //          pad[addr1] = t ^ b;
    //          addr2 = t & 0x7FFFF;
    //          b = t;
    //          t = pad[addr2];
    //          a += b * t;
    //          pad[addr2] = a;
    //          a ^= t;
    //      } 
    //  }
    //
UTEST_CRYPTONIGHT:
    // set arguments
    // a0 -> pad
    // a1 -> a
    // a2 -> b
    // a3 -> n
    li.w a0, 0x80400000
    li.w a1, 0xdeadbeef
    li.w a2, 0xfaceb00c
    li.w a3, 0x100000

    // generated by gcc
    or $r13,$r4,$r0
    or $r12,$r0,$r0
    lu12i.w $r14,524288>>12   # 0x80000
.LCN2:
    st.w $r12,$r13,0
    addi.w $r12,$r12,1
    addi.w $r13,$r13,4
    bne $r12,$r14,.LCN2
    beq $r7,$r0,.LCN1
    lu12i.w $r16,520192>>12   # 0x7f000
    or $r15,$r0,$r0
    ori $r16,$r16,4095
.LCN4:
    and $r14,$r5,$r16
    slli.w $r14,$r14,2
    add.w $r14,$r4,$r14
    ld.w $r13,$r14,0
    srli.w $r12,$r5,1
    addi.w $r15,$r15,1
    slli.w $r13,$r13,1
    xor $r12,$r13,$r12
    and $r13,$r12,$r16
    xor $r6,$r12,$r6
    slli.w $r13,$r13,2
    st.w $r6,$r14,0
    add.w $r13,$r4,$r13
    ld.w $r14,$r13,0
    or $r6,$r12,$r0
    mul.w $r12,$r12,$r14
    add.w $r12,$r12,$r5
    st.w $r12,$r13,0
    xor $r5,$r14,$r12
    bne $r7,$r15,.LCN4
.LCN1:
    jr $r1

    // 系统调用测试程序
    // 该测试仅在实现异常处理时有效
#ifdef ENABLE_INT
UTEST_PUTC:
    // 系统调用号保存在 a7
    li.w a7, SYS_putc
    // 参数 'O' 保存在 a0
    li.w a0, 0x4F
    syscall 0

    // 参数 'K' 保存在 a0
    li.w a0, 0x4B
    syscall 0
    jr ra
#endif


#define TESTLOOP64  0x04000000      /*  64M约6.7千万次   */
#define TESTLOOP32  0x02000000      /*  32M约3.4千万次   */
#define TESTLOOP16  0x01000000      /*  16M约1.7千万次   */

    // 性能标定程序(1)
    // 这段程序一般没有数据冲突和结构冲突，可作为性能标定。
    // 执行这段程序需至少 320M指令，320M/time 可算得频率。
UTEST_1PTB:
    li.w t0, TESTLOOP64
.LC0:
    addi.w t0, t0, -1
    ori t1, zero, 0
    ori t2, zero, 1
    ori t3, zero, 2
    bne t0, zero, .LC0

    jr ra

    // 运算数据冲突的效率测试(2)
    // 这段程序含有大量数据冲突，可测试数据冲突对效率的影响。
    // 执行这段程序需至少 176M 指令。
UTEST_2DCT:
    li.w t0, TESTLOOP16
    ori t1, zero, 1
    ori t2, zero, 2
    ori t3, zero, 3
.LC1:
    // 交换t1, t2
    xor t2, t2, t1
    xor t1, t1, t2
    xor t2, t2, t1
    // 交换t2, t3
    xor t3, t3, t2
    xor t2, t2, t3
    xor t3, t3, t2
    // 交换t3, t1
    xor t1, t1, t3
    xor t3, t3, t1
    xor t1, t1, t3

    addi.w t0, t0, -1
    bne t0, zero, .LC1

    jr ra

    // 控制指令冲突测试(3)
    // 这段程序有大量控制冲突。
    // 执行至少 256M 条指令。
UTEST_3CCT:
    li.w t0, TESTLOOP64
.LC2_0:
    bne t0, zero, .LC2_1
    jr ra
.LC2_1:
    b .LC2_2
.LC2_2:
    addi.w t0, t0, -1
    b .LC2_0
    addi.w t0, t0, -1

    // 访存相关数据冲突测试(4)
    // 这段程序反复对内存进行有数据冲突的读写。
    // 执行至少 192M 指令。
UTEST_4MDCT:
    li.w t0, TESTLOOP32
    addi.w sp, sp, -4
.LC3:
    st.w t0, sp, 0
    ld.w t1, sp, 0
    addi.w t1, t1, -1
    st.w t1, sp, 0
    ld.w t0, sp, 0
    bne t0, zero, .LC3

    addi.w sp, sp, 4
    jr ra
